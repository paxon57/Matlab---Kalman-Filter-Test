clear; clc;
%% Settings
% Simulation Settings
dt = 0.5; % seconds
max_time = 60; % seconds
map_size = 10000; % meters
% Initial Parameters
init_pos = [0, randi(map_size - 200) + 200];
ang = (rand() * 2 - 1) * pi / 3 + pi / 2;
speed = 150; % m/s
% Plane Behaviour
turn_speed = pi / 5;
turn_chance = 0.05;
acceleration = 9.81;
speed_change_chance = 0.03;
% Radar Parameters
radar_pos = [rand() * map_size, rand() * map_size];
range_noise = 100;
angle_noise = deg2rad(3);

%% Setup
total_samples = max_time / dt;
k = 1;
real_pos(1,:) = init_pos;
detection_pos(1, :) = real_pos(1, :) + (rand(1,2) * 2 - 1) * range_noise;
desired_ang = ang;
desired_speed = speed;
error = zeros(1, total_samples);
% Kalman Filter Setup
Q = [10 0 0 0;
    0 10 0 0;
    0 0 10 0;
    0 0 0 10]; % Process Covariance
R = [800 0;
    0 0.00023]; % Measurement Covariance
P = eye(4);
estimated_state(1,:) = [real_pos(1, :) + rand(1,2) * 1000, 150, 0];

%% Main Loop
for t = dt:dt:max_time
    k = k + 1;

    % Chance to turn
    if rand < turn_chance
        desired_ang = (rand() * 2 - 1) * pi / 4 + pi / 2;
        disp(['Turning to: ', num2str(desired_ang)]);
    end
    % Turning
    ang = ang + max(min(desired_ang - ang, turn_speed * dt), -turn_speed * dt);

    % Chance to change speed
    if rand < speed_change_chance
        desired_speed = 100 + rand * 150;
        disp(['Accelerating to: ', num2str(desired_speed)]);
    end
    % Accelerating
    speed = speed + max(min(desired_speed - speed, acceleration * dt), -acceleration * dt);
    
    % Move Real Plane
    real_pos(k,:) = real_pos(k-1,:) + [dt * speed * sin(ang), dt * speed * cos(ang)];
    
    %%% Kalman Filter
    %% Prediction
    %F = [1, 0, sin(estimated_state(k-1,4)) * dt, 0;
    %    0, 1, cos(estimated_state(k-1,4)) * dt, 0;
    %    0, 0, 1, 0;
    %    0, 0, 0, 1];
    F = [1, 0, dt, 0;
        0, 1, 0, dt;
        0, 0, 1, 0;
        0, 0, 0, 1];
    % State Prediction
    x_pred = (F*estimated_state(k-1,:)')';
    % Update state covariance
    P_pred = F * P * F' + Q;
    %% Update
    % Observation Matrix (Jacobian)
    diff = x_pred(1:2)' - radar_pos';
    H = [diff(1) / sqrt(diff(1)^2 + diff(2)^2), diff(2) / sqrt(diff(2)^2 + diff(1)^2), 0, 0;
        diff(2) / (diff(1)^2 + diff(2)^2), -(diff(1) / (diff(2)^2 + diff(1)^2)), 0, 0];
    % Kalman Gain
    K = (P_pred * H') / (H*P_pred*H' + R);
    % Simulated Measurements
    Z = measurement(real_pos(k, :)', radar_pos', [range_noise, angle_noise]);
    y = Z - measurement(x_pred(1:2)', radar_pos', [0 0]);
    % State Estimation
    x_est = x_pred' + K * y;
    P_est = (eye(4) - K*H)*P_pred;

    % Update Estimation
    estimated_state(k,:) = x_est';
    P = P_est;
    
    % Save Error
    err_dist = real_pos - estimated_state(k, 1:2);
    error(k) = sqrt(err_dist(1)^2 + err_dist(2)^2);

    % Detection Visualization
    detection_pos(k, :) = [radar_pos(1) + Z(1) * sin(Z(2));
        radar_pos(2) + Z(1) * cos(Z(2))];

    % Draw Simulation
    drawSimulation(k, map_size, radar_pos, real_pos, detection_pos, estimated_state);
    % Kinda Real Time
    %pause(dt);
end

%% Plot Error Over Time
figure;
t = 0:dt:max_time;
plot(t, error);
xlabel("Time (s)");